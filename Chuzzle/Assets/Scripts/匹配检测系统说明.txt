═══════════════════════════════════════════════════════
    匹配检测系统 (MatchFinder) - 完整说明
═══════════════════════════════════════════════════════

一、系统概述
──────────────────────────────────────────────

我们实现了一个完整的匹配检测系统，使用 Flood Fill（洪水填充）算法
来检测任意形状的连通区域。

【核心特性】
✅ 支持任意形状的匹配（不仅限于直线）
✅ 开局生成时自动避免3连匹配
✅ 高效的Flood Fill算法
✅ 可复用于后续消除逻辑
✅ 完善的调试功能


二、核心算法
──────────────────────────────────────────────

【算法1：Flood Fill 连通区域检测】
-----------------------------------------
原理：从一个宝石开始，递归/队列遍历四个方向（上下左右），
      找出所有颜色相同且连通的宝石。

应用场景：
  • 游戏中检测所有匹配
  • 移动后检测新形成的匹配
  • 检测复杂形状（L型、T型、十字等）

代码位置：
  MatchFinder.cs -> FindConnectedGems(int row, int col)

伪代码：
  1. 从起点宝石开始
  2. 创建一个队列和已访问集合
  3. 循环直到队列为空：
     - 取出当前宝石
     - 检查四个方向的邻居
     - 如果邻居颜色相同且未访问，加入队列
  4. 返回所有连通的宝石


【算法2：开局快速规则检测】
-----------------------------------------
原理：在生成时，只检查左边2个和上边2个是否相同，
      以及L型拐角的特殊情况。

应用场景：
  • 开局生成棋盘时避免初始匹配
  • 快速且足够准确

代码位置：
  MatchFinder.cs -> GetSafeTypeForGeneration(int row, int col)

规则：
  规则1：如果左边2个相同 -> 禁用该颜色
  规则2：如果上边2个相同 -> 禁用该颜色
  规则3：如果左上各1个相同 + 周围有连接 -> 禁用该颜色


三、主要方法说明
──────────────────────────────────────────────

【公开方法】
===========================================

1. FindAllMatchGroups()
   - 功能：找出整个棋盘上的所有匹配组
   - 返回：List<List<Gem>> - 每个List代表一个匹配组
   - 用途：游戏中消除匹配时调用

2. FindConnectedGems(int row, int col)
   - 功能：找出指定位置的连通宝石
   - 返回：List<Gem> - 所有连通的宝石
   - 用途：检测单个宝石周围的匹配

3. HasMatchAt(int row, int col)
   - 功能：快速判断某位置是否有匹配
   - 返回：bool
   - 用途：快速检测

4. GetSafeTypeForGeneration(int row, int col)
   - 功能：获取不会形成匹配的安全颜色（开局用）
   - 返回：GemType
   - 用途：开局生成棋盘

5. WouldCreateMatch(int row, int col, GemType type)
   - 功能：测试放置某颜色后是否会形成匹配（完整检测）
   - 返回：bool
   - 用途：精确预测

6. DebugShowAllMatches()
   - 功能：在Console中打印所有匹配（调试用）
   - 用途：测试和调试


四、集成到BoardManager
──────────────────────────────────────────────

【修改点】
===========================================

1. Start() 中初始化：
   matchFinder = new MatchFinder(this);

2. GenerateBoard() 中使用安全颜色：
   // 旧代码：
   GemType gemType = GetRandomGemType();
   
   // 新代码：
   GemType gemType = matchFinder.GetSafeTypeForGeneration(row, col);

3. 开局验证：
   var matches = matchFinder.FindAllMatchGroups();
   if (matches.Count > 0) 警告
   else 成功

4. 新增方法：
   • public int Rows => rows;  // 供MatchFinder访问
   • SetGemForTest(...)  // 供测试用
   • GetMatchFinder()  // 供外部获取


五、调试功能
──────────────────────────────────────────────

【按键操作】
===========================================

按 M 键 -> 手动检测当前棋盘的所有匹配

【Console输出格式】
===========================================

示例1：无匹配
  没有发现匹配

示例2：有匹配
  发现 2 个匹配组：
    匹配组1: 4个Blue - 位置: (0,0), (0,1), (1,0), (1,1)
    匹配组2: 3个Red - 位置: (3,4), (3,5), (4,4)


六、后续扩展方向
──────────────────────────────────────────────

✅ 已完成：
  • 开局无匹配生成
  • Flood Fill检测

🚀 可以添加：
  1. 移动后自动检测并消除匹配
  2. 连锁反应（消除后下落，再次检测）
  3. 特殊匹配奖励（4连、5连、L型等）
  4. 无解检测（是否还有可移动的匹配）
  5. 提示系统（高亮可能的匹配移动）


七、性能考虑
──────────────────────────────────────────────

【时间复杂度】
===========================================

Flood Fill算法：O(n) - n为宝石数量
开局生成检测：O(1) - 只检查固定位置
全棋盘检测：O(rows × cols) - 遍历整个棋盘

【优化建议】
===========================================

对于6×6棋盘：性能已经足够
对于更大棋盘：
  • 只检测移动相关的区域
  • 缓存上一次的检测结果
  • 使用增量更新


八、测试方法
──────────────────────────────────────────────

【测试1：开局无匹配】
运行游戏 -> 查看Console
应该看到：✅ 开局无匹配，生成成功！

【测试2：手动测试】
多次重新开始游戏，每次都应该无匹配

【测试3：拖动后测试】
拖动一行/列 -> 按M键
应该能检测到新形成的匹配

【测试4：极端情况】
尝试生成100次，统计失败率（应该为0）


九、代码位置总览
──────────────────────────────────────────────

Assets/Scripts/
  ├── MatchFinder.cs         # 匹配检测核心
  ├── BoardManager.cs        # 集成匹配检测
  ├── Gem.cs                # 宝石基础类
  ├── InputController.cs    # 输入控制
  └── 匹配检测系统说明.txt   # 本文件


═══════════════════════════════════════════════════════
    开始测试吧！按M键即可检测匹配 🎮
═══════════════════════════════════════════════════════

