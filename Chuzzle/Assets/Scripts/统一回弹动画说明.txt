=====================================================
🎯 统一回弹动画 - 本体和影子一起移动！
=====================================================

✅ 问题已修复！
-----------------

之前的错误：
❌ 影子立即消失或独立淡出
❌ 本体和影子分开处理
❌ 不协调、不统一

现在的正确效果：
✅ 本体和影子一起回弹
✅ 整行/整列统一动画
✅ 回弹完成后影子才消失


🎬 正确的视觉效果：
-----------------

向右拖动0.4格后释放：

拖动中：
[F影][A.][B.][C.][D.][E.][.F]
 ↑在边界外    全部向右偏移0.4

释放鼠标 → 开始回弹：

第1帧（progress 0%）：
[F影][A.][B.][C.][D.][E.][.F]
 ↑影子还在      偏移还是0.4

第2帧（progress 30%）：
[F影回][A回][B回][C回][D回][E回][F回]
 ↑影子跟着一起回！   偏移变成0.28

第3帧（progress 70%）：
[F影回][A回][B回][C回][D回][E回][F回]
 ↑继续一起回      偏移变成0.12

第4帧（progress 100%）：
[F影][A][B][C][D][E][F]
 ↑在边界外原位   全部回到原位，偏移=0

然后：影子消失
[A][B][C][D][E][F]

✅ 整体协调！
✅ 本体和影子同步！
✅ 最后才消失！


🔑 核心技术原理：
-----------------

关键公式：
```
本体位置 = 基础位置 + 回弹偏移
影子位置 = 影子基础位置 + 回弹偏移
              ↑                 ↑
         (边界外)          (同样的偏移！)
```

示例计算：
```
向右拖动0.4格：

本体A:
- 基础位置: -3.0
- 拖动偏移: +0.4
- 当前位置: -3.0 + 0.4 = -2.6

影子A:
- 影子基础位置: -3.0 - 7.2 = -10.2（边界外）
- 拖动偏移: +0.4（和本体一样！）
- 当前位置: -10.2 + 0.4 = -9.8

回弹到50%:
- 偏移变为: 0.4 → 0.2
- 本体位置: -3.0 + 0.2 = -2.8
- 影子位置: -10.2 + 0.2 = -10.0
  ↑ 都在向原位移动！

回弹完成:
- 偏移变为: 0.4 → 0.0
- 本体位置: -3.0 + 0.0 = -3.0（原位）
- 影子位置: -10.2 + 0.0 = -10.2（边界外原位）

然后销毁影子
```


💡 实现细节：
-----------------

1. Gem.cs 新增：
   ```csharp
   shadowBasePosition - 影子的基础位置
   ```
   
2. CreateOrUpdateShadow() 改进：
   ```csharp
   shadowBasePosition = shadowPosition - visualOffset
   ```
   保存影子的"基础位置"（不含拖动偏移）
   
3. Update() 回弹逻辑：
   ```csharp
   // 本体回弹
   visualOffset = Lerp(起始偏移, 0, progress)
   transform.position = basePosition + visualOffset
   
   // 影子跟随相同的偏移
   shadowGem.position = shadowBasePosition + visualOffset
   ```
   
4. 完成后销毁：
   ```csharp
   if (progress >= 1.0)
   {
       DestroyShadow()  // 最后才销毁
   }
   ```


🎯 关键点对比：
-----------------

| 项目 | 旧版 | 新版 |
|------|------|------|
| 影子处理 | 淡出/立即消失 | **跟随回弹** ✨ |
| 移动方式 | 独立处理 | **统一偏移** ✨ |
| 消失时机 | 回弹开始时 | **回弹完成后** ✨ |
| 视觉协调 | ❌ 分离 | ✅ **统一** ✨ |
| 物理感 | 一般 | **很强** ✨ |


📊 数学原理：
-----------------

为什么影子要用"shadowBasePosition"？

本体：
  原始位置: A
  拖动后: A + offset
  回弹: A + offset → A + 0

影子：
  原始位置: A - 循环宽度（在边界外）
  拖动后: (A - 循环宽度) + offset
  回弹: (A - 循环宽度) + offset → (A - 循环宽度) + 0
  
关键：两者使用相同的offset变化！
这样才能同步移动！


🌊 波浪效果保留：
-----------------

依次回弹的顺序仍然保留：
- 第0列：延迟0.00秒开始回弹
- 第1列：延迟0.03秒开始回弹
- 第2列：延迟0.06秒开始回弹
- ...

但每个宝石的本体和影子是同步的：
```
第0列开始回弹:
  本体0回弹 + 影子0回弹（同步）

0.03秒后，第1列开始回弹:
  本体1回弹 + 影子1回弹（同步）

结果：波浪从一边传到另一边
      但每个"波"包含本体和影子
```


🎬 完整流程图：
-----------------

```
拖动中:
[影0][本0][本1][本2][本3][本4][本5]
 ↑全部有同样的偏移offset

释放 → 回弹开始:

列0开始(delay=0.00s):
[影0回][本0回][本1][本2][本3][本4][本5]
 ↑同步回弹

列1开始(delay=0.03s):
[影0回][本0回][影1回][本1回][本2][本3][本4][本5]
        ↑同步回弹

依次传递...

全部回弹完成:
[影0][本0][本1][本2][本3][本4][本5]
 ↑在边界外原位

销毁影子:
[本0][本1][本2][本3][本4][本5]
```


✨ 视觉体验：
-----------------

玩家视角：
1. 拖动宝石（看到循环带）
2. 释放鼠标
3. 看到整行宝石（包括影子）像波浪一样回弹
4. 本体和影子完美同步
5. 回弹完成后影子消失
6. 😍 "超级流畅！很协调！"

心理感受：
✅ 整体性强
✅ 协调统一
✅ 物理真实感
✅ 专业品质


🔍 调试验证：
-----------------

在Scene视图中观察：
1. 释放鼠标后
2. 暂停游戏（点击Pause）
3. 逐帧观察（右箭头键）
4. 你会看到：
   - 本体在回弹
   - 影子也在回弹
   - 两者偏移完全相同
   - 最后影子才消失


⚙️ 参数影响：
-----------------

bounceDuration（回弹时长）：
- 影响所有宝石的回弹速度
- 本体和影子同步受影响

delayIncrement（波浪延迟）：
- 只影响开始时机
- 不影响本体和影子的同步性


📝 总结：
-----------------

核心改进：
1. 影子有了"基础位置"概念
2. 回弹时影子使用相同的偏移变化
3. 完成后才销毁影子

结果：
✅ 本体和影子完美同步
✅ 整行/整列协调统一
✅ 视觉效果一流
✅ 物理感真实


🚀 现在测试：
-----------------

1. 运行Unity
2. 拖动一行宝石（不要超过半格）
3. 释放鼠标
4. 观察：
   ✅ 本体和影子一起回弹！
   ✅ 整行波浪效果！
   ✅ 完成后影子才消失！
   ✅ 超级协调流畅！


=====================================================
完美的统一回弹动画！
本体和影子就像一个整体，协调优雅！✨
=====================================================


